<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>USTool.utils.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>USTool.utils.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import cv2
from queue import Queue
from threading import Thread
import os
from config import imshape
import json
import numpy as np
from config import hues, labels, imshape, mode
import pydensecrf.densecrf as dcrf
from pydensecrf.utils import unary_from_softmax
from tensorflow.keras.utils import to_categorical


class VideoStream:
    def __init__(self, device=0, size=100):
        self.stream = cv2.VideoCapture(device)
        self.stream.set(cv2.CAP_PROP_FPS, 15)
        self.stopped = False
        self.queue = Queue(maxsize=size)

    def start(self):
        thread = Thread(target=self.update, args=())
        thread.daemon = True
        thread.start()
        return self

    def update(self):
        while self.stopped is False:

            if not self.queue.full():
                (grabbed, frame) = self.stream.read()

            if not grabbed:
                self.stop()
                return

            self.queue.put(frame)

    def read(self):
        return self.queue.get()

    def check_queue(self):
        return self.queue.qsize() &gt; 0

    def stop(self):
        self.stopped = True
        self.stream.release()

def load_img_from_json(annot_path):
    with open(annot_path) as handle:
        data = json.load(handle)

    return data[&#39;imagePath&#39;]


def generate_missing_json():

    # creates a background json for the entire image if missing
    # this assumes you will never annotate a background class

    for im in os.listdir(&#39;dataset/QualiCarnes/images&#39;):
        fn = im.split(&#39;.&#39;)[0]+&#39;.json&#39;
        path = os.path.join(&#39;dataset/QualiCarnes/annotated&#39;, fn)

        if os.path.exists(path) is False:
            json_dict = {}

            # these points might be reversed if not using a square image (idk)
            json_dict[&#39;shapes&#39;] = [{&#34;label&#34;: &#34;background&#34;,
                                    &#34;points&#34;: [[0,0],
                                               [0, imshape[0]-1],
                                               [imshape[0]-1, imshape[1]-1],
                                               [imshape[0]-1, 0]]
                                    }]
            with open(path, &#39;w&#39;) as handle:
                json.dump(json_dict, handle, indent=2)


def add_masks(pred):
    blank = np.zeros(shape=imshape, dtype=np.uint8)

    print(f&#39;len labels: {len(labels)}&#39;)

    for i, label in enumerate(labels):
        hue = np.full(shape=(imshape[0], imshape[1]), fill_value=hues[label], dtype=np.uint8)
        sat = np.full(shape=(imshape[0], imshape[1]), fill_value=255, dtype=np.uint8)
        val = pred[:,:,i].astype(np.uint8)

        im_hsv = cv2.merge([hue, sat, val])
        im_rgb = cv2.cvtColor(im_hsv, cv2.COLOR_HSV2RGB)
        blank = cv2.add(blank, im_rgb)

    return blank


def crf(im_softmax, im_rgb):
    n_classes = im_softmax.shape[2]
    feat_first = im_softmax.transpose((2, 0, 1)).reshape(n_classes, -1)
    unary = unary_from_softmax(feat_first)
    unary = np.ascontiguousarray(unary)
    im_rgb = np.ascontiguousarray(im_rgb)

    d = dcrf.DenseCRF2D(im_rgb.shape[1], im_rgb.shape[0], n_classes)

    d.setUnaryEnergy(unary)
    d.addPairwiseGaussian(sxy=(5, 5), compat=3, kernel=dcrf.DIAG_KERNEL,
                              normalization=dcrf.NORMALIZE_SYMMETRIC)

    # This adds the color-dependent term, i.e. features are (x,y,r,g,b).
    d.addPairwiseBilateral(sxy=(5, 5), srgb=(13, 13, 13), rgbim=im_rgb,
                           compat=10,
                           kernel=dcrf.DIAG_KERNEL,
                           normalization=dcrf.NORMALIZE_SYMMETRIC)
    Q = d.inference(5)
    res = np.argmax(Q, axis=0).reshape((im_rgb.shape[0], im_rgb.shape[1]))
    if mode is &#39;binary&#39;:
        return res * 255.0
    if mode is &#39;multi&#39;:
        res_hot = to_categorical(res) * 255.0
        res_crf = add_masks(res_hot)
        return res_crf

def get_pixel_area(segm):
    return segm.shape[0] * segm.shape[1]

def extract_both_masks(eval_segm, gt_segm, cl, n_cl):
    eval_mask = extract_masks(eval_segm, cl, n_cl)
    gt_mask   = extract_masks(gt_segm, cl, n_cl)
    return eval_mask, gt_mask

def extract_classes(segm):
    cl = np.unique(segm)
    n_cl = len(cl)
    return cl, n_cl

def union_classes(eval_segm, gt_segm):
    eval_cl, _ = extract_classes(eval_segm)
    gt_cl, _   = extract_classes(gt_segm)

    cl = np.union1d(eval_cl, gt_cl)
    n_cl = len(cl)

    return cl, n_cl

def extract_masks(segm, cl, n_cl):
    h, w  = segm_size(segm)
    masks = np.zeros((n_cl, h, w))
    print(f&#39;size segm: {segm.shape}&#39;)
    print(f&#39;mask segm: {masks.shape}&#39;)
    for i, c in enumerate(cl):
        masks[i, :, :] = segm[:,:, i] == c
    return masks

def segm_size(segm):
    try:
        height = segm.shape[0]
        width  = segm.shape[1]
    except IndexError:
        raise
    return height, width

def check_size(eval_segm, gt_segm):
    h_e, w_e = segm_size(eval_segm)
    h_g, w_g = segm_size(gt_segm)
    if (h_e != h_g) or (w_e != w_g):
        raise EvalSegErr(&#34;DiffDim: Different dimensions of matrices!&#34;)

def get_not_borders(curr_gt_mask):
    borders_dilation = binary_dilation(curr_gt_mask, iterations=3).astype(curr_gt_mask.dtype)
    borders_erosion = binary_erosion(curr_gt_mask, iterations=3).astype(curr_gt_mask.dtype)
    borders = np.bitwise_not(np.logical_or(borders_dilation != curr_gt_mask, borders_erosion != curr_gt_mask))
    return borders

def pixel_area(eval_segm, gt_segm, cl=None):
    &#39;&#39;&#39;
    sum_i(n_ii) / sum_i(t_i)
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    if cl is None:
        cl, n_cl = extract_classes(gt_segm)
    else:
        n_cl = len(cl)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    area_gt = list([0]) * n_cl
    area_eval = list([0]) * n_cl
    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        area_eval[i] = np.sum(curr_eval_mask)
        area_gt[i] = np.sum(curr_gt_mask)

    return area_eval, area_gt

def mean_accuracy(eval_segm, gt_segm, ignore_border=False, cl=None):
    &#39;&#39;&#39;
    (1/n_cl) sum_i(n_ii/t_i)
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    if cl is None:
        cl, n_cl = extract_classes(gt_segm)
    else:
        n_cl = len(cl)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    accuracy = list([0]) * n_cl

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        if ignore_border:
            not_borders = get_not_borders(curr_gt_mask)

            n_ii = np.logical_and(curr_eval_mask, curr_gt_mask)
            n_ii = np.sum(n_ii[not_borders])
            t_i  = np.sum(curr_gt_mask[not_borders])
        else:
            n_ii = np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
            t_i  = np.sum(curr_gt_mask)

        if (t_i != 0):
            accuracy[i] = n_ii / t_i
        else:
            accuracy[i] = 1.

    mean_accuracy_ = np.mean(accuracy)
    return mean_accuracy_, accuracy

def pixel_accuracy(eval_segm, gt_segm):
    &#39;&#39;&#39;
    sum_i(n_ii) / sum_i(t_i)
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    cl, n_cl = extract_classes(gt_segm)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    sum_n_ii = 0
    sum_t_i  = 0

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        sum_n_ii += np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
        sum_t_i  += np.sum(curr_gt_mask)

    if (sum_t_i == 0):
        pixel_accuracy_ = 0
    else:
        pixel_accuracy_ = sum_n_ii / sum_t_i

    return pixel_accuracy_

def mean_IU(eval_segm, gt_segm, ignore_border=False, cl=None):
    &#39;&#39;&#39;
    (1/n_cl) * sum_i(n_ii / (t_i + sum_j(n_ji) - n_ii))
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    if cl is None:
        cl, n_cl   = union_classes(eval_segm, gt_segm)
    else:
        n_cl = len(cl)
    _, n_cl_gt = extract_classes(gt_segm)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    IU = list([0]) * n_cl

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        if ignore_border:
            not_borders = get_not_borders(curr_gt_mask)
            n_ii = np.logical_and(curr_eval_mask, curr_gt_mask)
            n_ii = np.sum(n_ii[not_borders])

            t_i  = np.sum(curr_gt_mask[not_borders])
            n_ij = np.sum(curr_eval_mask[not_borders])
        else:
            n_ii = np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
            t_i  = np.sum(curr_gt_mask)
            n_ij = np.sum(curr_eval_mask)

        if (n_ij == 0) or (t_i) == 0:
            IU[i] = 1.
            continue

        IU[i] = n_ii / (t_i + n_ij - n_ii)

    mean_IU_ = np.sum(IU) / n_cl_gt
    return mean_IU_, IU

def frequency_weighted_IU(eval_segm, gt_segm):
    &#39;&#39;&#39;
    sum_k(t_k)^(-1) * sum_i((t_i*n_ii)/(t_i + sum_j(n_ji) - n_ii))
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    cl, n_cl = union_classes(eval_segm, gt_segm)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    frequency_weighted_IU_ = list([0]) * n_cl

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        if (np.sum(curr_eval_mask) == 0) or (np.sum(curr_gt_mask) == 0):
            continue

        n_ii = np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
        t_i  = np.sum(curr_gt_mask)
        n_ij = np.sum(curr_eval_mask)

        frequency_weighted_IU_[i] = (t_i * n_ii) / (t_i + n_ij - n_ii)

    sum_k_t_k = get_pixel_area(eval_segm)

    frequency_weighted_IU_ = np.sum(frequency_weighted_IU_) / sum_k_t_k
    return frequency_weighted_IU_</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="USTool.utils.utils.add_masks"><code class="name flex">
<span>def <span class="ident">add_masks</span></span>(<span>pred)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_masks(pred):
    blank = np.zeros(shape=imshape, dtype=np.uint8)

    print(f&#39;len labels: {len(labels)}&#39;)

    for i, label in enumerate(labels):
        hue = np.full(shape=(imshape[0], imshape[1]), fill_value=hues[label], dtype=np.uint8)
        sat = np.full(shape=(imshape[0], imshape[1]), fill_value=255, dtype=np.uint8)
        val = pred[:,:,i].astype(np.uint8)

        im_hsv = cv2.merge([hue, sat, val])
        im_rgb = cv2.cvtColor(im_hsv, cv2.COLOR_HSV2RGB)
        blank = cv2.add(blank, im_rgb)

    return blank</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.check_size"><code class="name flex">
<span>def <span class="ident">check_size</span></span>(<span>eval_segm, gt_segm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_size(eval_segm, gt_segm):
    h_e, w_e = segm_size(eval_segm)
    h_g, w_g = segm_size(gt_segm)
    if (h_e != h_g) or (w_e != w_g):
        raise EvalSegErr(&#34;DiffDim: Different dimensions of matrices!&#34;)</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.crf"><code class="name flex">
<span>def <span class="ident">crf</span></span>(<span>im_softmax, im_rgb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def crf(im_softmax, im_rgb):
    n_classes = im_softmax.shape[2]
    feat_first = im_softmax.transpose((2, 0, 1)).reshape(n_classes, -1)
    unary = unary_from_softmax(feat_first)
    unary = np.ascontiguousarray(unary)
    im_rgb = np.ascontiguousarray(im_rgb)

    d = dcrf.DenseCRF2D(im_rgb.shape[1], im_rgb.shape[0], n_classes)

    d.setUnaryEnergy(unary)
    d.addPairwiseGaussian(sxy=(5, 5), compat=3, kernel=dcrf.DIAG_KERNEL,
                              normalization=dcrf.NORMALIZE_SYMMETRIC)

    # This adds the color-dependent term, i.e. features are (x,y,r,g,b).
    d.addPairwiseBilateral(sxy=(5, 5), srgb=(13, 13, 13), rgbim=im_rgb,
                           compat=10,
                           kernel=dcrf.DIAG_KERNEL,
                           normalization=dcrf.NORMALIZE_SYMMETRIC)
    Q = d.inference(5)
    res = np.argmax(Q, axis=0).reshape((im_rgb.shape[0], im_rgb.shape[1]))
    if mode is &#39;binary&#39;:
        return res * 255.0
    if mode is &#39;multi&#39;:
        res_hot = to_categorical(res) * 255.0
        res_crf = add_masks(res_hot)
        return res_crf</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.extract_both_masks"><code class="name flex">
<span>def <span class="ident">extract_both_masks</span></span>(<span>eval_segm, gt_segm, cl, n_cl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_both_masks(eval_segm, gt_segm, cl, n_cl):
    eval_mask = extract_masks(eval_segm, cl, n_cl)
    gt_mask   = extract_masks(gt_segm, cl, n_cl)
    return eval_mask, gt_mask</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.extract_classes"><code class="name flex">
<span>def <span class="ident">extract_classes</span></span>(<span>segm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_classes(segm):
    cl = np.unique(segm)
    n_cl = len(cl)
    return cl, n_cl</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.extract_masks"><code class="name flex">
<span>def <span class="ident">extract_masks</span></span>(<span>segm, cl, n_cl)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_masks(segm, cl, n_cl):
    h, w  = segm_size(segm)
    masks = np.zeros((n_cl, h, w))
    print(f&#39;size segm: {segm.shape}&#39;)
    print(f&#39;mask segm: {masks.shape}&#39;)
    for i, c in enumerate(cl):
        masks[i, :, :] = segm[:,:, i] == c
    return masks</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.frequency_weighted_IU"><code class="name flex">
<span>def <span class="ident">frequency_weighted_IU</span></span>(<span>eval_segm, gt_segm)</span>
</code></dt>
<dd>
<div class="desc"><p>sum_k(t_k)^(-1) * sum_i((t_i*n_ii)/(t_i + sum_j(n_ji) - n_ii))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frequency_weighted_IU(eval_segm, gt_segm):
    &#39;&#39;&#39;
    sum_k(t_k)^(-1) * sum_i((t_i*n_ii)/(t_i + sum_j(n_ji) - n_ii))
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    cl, n_cl = union_classes(eval_segm, gt_segm)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    frequency_weighted_IU_ = list([0]) * n_cl

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        if (np.sum(curr_eval_mask) == 0) or (np.sum(curr_gt_mask) == 0):
            continue

        n_ii = np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
        t_i  = np.sum(curr_gt_mask)
        n_ij = np.sum(curr_eval_mask)

        frequency_weighted_IU_[i] = (t_i * n_ii) / (t_i + n_ij - n_ii)

    sum_k_t_k = get_pixel_area(eval_segm)

    frequency_weighted_IU_ = np.sum(frequency_weighted_IU_) / sum_k_t_k
    return frequency_weighted_IU_</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.generate_missing_json"><code class="name flex">
<span>def <span class="ident">generate_missing_json</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_missing_json():

    # creates a background json for the entire image if missing
    # this assumes you will never annotate a background class

    for im in os.listdir(&#39;dataset/QualiCarnes/images&#39;):
        fn = im.split(&#39;.&#39;)[0]+&#39;.json&#39;
        path = os.path.join(&#39;dataset/QualiCarnes/annotated&#39;, fn)

        if os.path.exists(path) is False:
            json_dict = {}

            # these points might be reversed if not using a square image (idk)
            json_dict[&#39;shapes&#39;] = [{&#34;label&#34;: &#34;background&#34;,
                                    &#34;points&#34;: [[0,0],
                                               [0, imshape[0]-1],
                                               [imshape[0]-1, imshape[1]-1],
                                               [imshape[0]-1, 0]]
                                    }]
            with open(path, &#39;w&#39;) as handle:
                json.dump(json_dict, handle, indent=2)</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.get_not_borders"><code class="name flex">
<span>def <span class="ident">get_not_borders</span></span>(<span>curr_gt_mask)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_not_borders(curr_gt_mask):
    borders_dilation = binary_dilation(curr_gt_mask, iterations=3).astype(curr_gt_mask.dtype)
    borders_erosion = binary_erosion(curr_gt_mask, iterations=3).astype(curr_gt_mask.dtype)
    borders = np.bitwise_not(np.logical_or(borders_dilation != curr_gt_mask, borders_erosion != curr_gt_mask))
    return borders</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.get_pixel_area"><code class="name flex">
<span>def <span class="ident">get_pixel_area</span></span>(<span>segm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixel_area(segm):
    return segm.shape[0] * segm.shape[1]</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.load_img_from_json"><code class="name flex">
<span>def <span class="ident">load_img_from_json</span></span>(<span>annot_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_img_from_json(annot_path):
    with open(annot_path) as handle:
        data = json.load(handle)

    return data[&#39;imagePath&#39;]</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.mean_IU"><code class="name flex">
<span>def <span class="ident">mean_IU</span></span>(<span>eval_segm, gt_segm, ignore_border=False, cl=None)</span>
</code></dt>
<dd>
<div class="desc"><p>(1/n_cl) * sum_i(n_ii / (t_i + sum_j(n_ji) - n_ii))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_IU(eval_segm, gt_segm, ignore_border=False, cl=None):
    &#39;&#39;&#39;
    (1/n_cl) * sum_i(n_ii / (t_i + sum_j(n_ji) - n_ii))
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    if cl is None:
        cl, n_cl   = union_classes(eval_segm, gt_segm)
    else:
        n_cl = len(cl)
    _, n_cl_gt = extract_classes(gt_segm)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    IU = list([0]) * n_cl

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        if ignore_border:
            not_borders = get_not_borders(curr_gt_mask)
            n_ii = np.logical_and(curr_eval_mask, curr_gt_mask)
            n_ii = np.sum(n_ii[not_borders])

            t_i  = np.sum(curr_gt_mask[not_borders])
            n_ij = np.sum(curr_eval_mask[not_borders])
        else:
            n_ii = np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
            t_i  = np.sum(curr_gt_mask)
            n_ij = np.sum(curr_eval_mask)

        if (n_ij == 0) or (t_i) == 0:
            IU[i] = 1.
            continue

        IU[i] = n_ii / (t_i + n_ij - n_ii)

    mean_IU_ = np.sum(IU) / n_cl_gt
    return mean_IU_, IU</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.mean_accuracy"><code class="name flex">
<span>def <span class="ident">mean_accuracy</span></span>(<span>eval_segm, gt_segm, ignore_border=False, cl=None)</span>
</code></dt>
<dd>
<div class="desc"><p>(1/n_cl) sum_i(n_ii/t_i)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_accuracy(eval_segm, gt_segm, ignore_border=False, cl=None):
    &#39;&#39;&#39;
    (1/n_cl) sum_i(n_ii/t_i)
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    if cl is None:
        cl, n_cl = extract_classes(gt_segm)
    else:
        n_cl = len(cl)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    accuracy = list([0]) * n_cl

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        if ignore_border:
            not_borders = get_not_borders(curr_gt_mask)

            n_ii = np.logical_and(curr_eval_mask, curr_gt_mask)
            n_ii = np.sum(n_ii[not_borders])
            t_i  = np.sum(curr_gt_mask[not_borders])
        else:
            n_ii = np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
            t_i  = np.sum(curr_gt_mask)

        if (t_i != 0):
            accuracy[i] = n_ii / t_i
        else:
            accuracy[i] = 1.

    mean_accuracy_ = np.mean(accuracy)
    return mean_accuracy_, accuracy</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.pixel_accuracy"><code class="name flex">
<span>def <span class="ident">pixel_accuracy</span></span>(<span>eval_segm, gt_segm)</span>
</code></dt>
<dd>
<div class="desc"><p>sum_i(n_ii) / sum_i(t_i)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixel_accuracy(eval_segm, gt_segm):
    &#39;&#39;&#39;
    sum_i(n_ii) / sum_i(t_i)
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    cl, n_cl = extract_classes(gt_segm)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    sum_n_ii = 0
    sum_t_i  = 0

    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        sum_n_ii += np.sum(np.logical_and(curr_eval_mask, curr_gt_mask))
        sum_t_i  += np.sum(curr_gt_mask)

    if (sum_t_i == 0):
        pixel_accuracy_ = 0
    else:
        pixel_accuracy_ = sum_n_ii / sum_t_i

    return pixel_accuracy_</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.pixel_area"><code class="name flex">
<span>def <span class="ident">pixel_area</span></span>(<span>eval_segm, gt_segm, cl=None)</span>
</code></dt>
<dd>
<div class="desc"><p>sum_i(n_ii) / sum_i(t_i)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pixel_area(eval_segm, gt_segm, cl=None):
    &#39;&#39;&#39;
    sum_i(n_ii) / sum_i(t_i)
    &#39;&#39;&#39;

    check_size(eval_segm, gt_segm)

    if cl is None:
        cl, n_cl = extract_classes(gt_segm)
    else:
        n_cl = len(cl)
    eval_mask, gt_mask = extract_both_masks(eval_segm, gt_segm, cl, n_cl)

    area_gt = list([0]) * n_cl
    area_eval = list([0]) * n_cl
    for i, c in enumerate(cl):
        curr_eval_mask = eval_mask[i, :, :]
        curr_gt_mask = gt_mask[i, :, :]

        area_eval[i] = np.sum(curr_eval_mask)
        area_gt[i] = np.sum(curr_gt_mask)

    return area_eval, area_gt</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.segm_size"><code class="name flex">
<span>def <span class="ident">segm_size</span></span>(<span>segm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segm_size(segm):
    try:
        height = segm.shape[0]
        width  = segm.shape[1]
    except IndexError:
        raise
    return height, width</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.union_classes"><code class="name flex">
<span>def <span class="ident">union_classes</span></span>(<span>eval_segm, gt_segm)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union_classes(eval_segm, gt_segm):
    eval_cl, _ = extract_classes(eval_segm)
    gt_cl, _   = extract_classes(gt_segm)

    cl = np.union1d(eval_cl, gt_cl)
    n_cl = len(cl)

    return cl, n_cl</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="USTool.utils.utils.VideoStream"><code class="flex name class">
<span>class <span class="ident">VideoStream</span></span>
<span>(</span><span>device=0, size=100)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VideoStream:
    def __init__(self, device=0, size=100):
        self.stream = cv2.VideoCapture(device)
        self.stream.set(cv2.CAP_PROP_FPS, 15)
        self.stopped = False
        self.queue = Queue(maxsize=size)

    def start(self):
        thread = Thread(target=self.update, args=())
        thread.daemon = True
        thread.start()
        return self

    def update(self):
        while self.stopped is False:

            if not self.queue.full():
                (grabbed, frame) = self.stream.read()

            if not grabbed:
                self.stop()
                return

            self.queue.put(frame)

    def read(self):
        return self.queue.get()

    def check_queue(self):
        return self.queue.qsize() &gt; 0

    def stop(self):
        self.stopped = True
        self.stream.release()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="USTool.utils.utils.VideoStream.check_queue"><code class="name flex">
<span>def <span class="ident">check_queue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_queue(self):
    return self.queue.qsize() &gt; 0</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.VideoStream.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
    return self.queue.get()</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.VideoStream.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    thread = Thread(target=self.update, args=())
    thread.daemon = True
    thread.start()
    return self</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.VideoStream.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.stopped = True
    self.stream.release()</code></pre>
</details>
</dd>
<dt id="USTool.utils.utils.VideoStream.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    while self.stopped is False:

        if not self.queue.full():
            (grabbed, frame) = self.stream.read()

        if not grabbed:
            self.stop()
            return

        self.queue.put(frame)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="USTool.utils" href="index.html">USTool.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="USTool.utils.utils.add_masks" href="#USTool.utils.utils.add_masks">add_masks</a></code></li>
<li><code><a title="USTool.utils.utils.check_size" href="#USTool.utils.utils.check_size">check_size</a></code></li>
<li><code><a title="USTool.utils.utils.crf" href="#USTool.utils.utils.crf">crf</a></code></li>
<li><code><a title="USTool.utils.utils.extract_both_masks" href="#USTool.utils.utils.extract_both_masks">extract_both_masks</a></code></li>
<li><code><a title="USTool.utils.utils.extract_classes" href="#USTool.utils.utils.extract_classes">extract_classes</a></code></li>
<li><code><a title="USTool.utils.utils.extract_masks" href="#USTool.utils.utils.extract_masks">extract_masks</a></code></li>
<li><code><a title="USTool.utils.utils.frequency_weighted_IU" href="#USTool.utils.utils.frequency_weighted_IU">frequency_weighted_IU</a></code></li>
<li><code><a title="USTool.utils.utils.generate_missing_json" href="#USTool.utils.utils.generate_missing_json">generate_missing_json</a></code></li>
<li><code><a title="USTool.utils.utils.get_not_borders" href="#USTool.utils.utils.get_not_borders">get_not_borders</a></code></li>
<li><code><a title="USTool.utils.utils.get_pixel_area" href="#USTool.utils.utils.get_pixel_area">get_pixel_area</a></code></li>
<li><code><a title="USTool.utils.utils.load_img_from_json" href="#USTool.utils.utils.load_img_from_json">load_img_from_json</a></code></li>
<li><code><a title="USTool.utils.utils.mean_IU" href="#USTool.utils.utils.mean_IU">mean_IU</a></code></li>
<li><code><a title="USTool.utils.utils.mean_accuracy" href="#USTool.utils.utils.mean_accuracy">mean_accuracy</a></code></li>
<li><code><a title="USTool.utils.utils.pixel_accuracy" href="#USTool.utils.utils.pixel_accuracy">pixel_accuracy</a></code></li>
<li><code><a title="USTool.utils.utils.pixel_area" href="#USTool.utils.utils.pixel_area">pixel_area</a></code></li>
<li><code><a title="USTool.utils.utils.segm_size" href="#USTool.utils.utils.segm_size">segm_size</a></code></li>
<li><code><a title="USTool.utils.utils.union_classes" href="#USTool.utils.utils.union_classes">union_classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="USTool.utils.utils.VideoStream" href="#USTool.utils.utils.VideoStream">VideoStream</a></code></h4>
<ul class="">
<li><code><a title="USTool.utils.utils.VideoStream.check_queue" href="#USTool.utils.utils.VideoStream.check_queue">check_queue</a></code></li>
<li><code><a title="USTool.utils.utils.VideoStream.read" href="#USTool.utils.utils.VideoStream.read">read</a></code></li>
<li><code><a title="USTool.utils.utils.VideoStream.start" href="#USTool.utils.utils.VideoStream.start">start</a></code></li>
<li><code><a title="USTool.utils.utils.VideoStream.stop" href="#USTool.utils.utils.VideoStream.stop">stop</a></code></li>
<li><code><a title="USTool.utils.utils.VideoStream.update" href="#USTool.utils.utils.VideoStream.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>